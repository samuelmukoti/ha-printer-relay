#!/usr/bin/with-contenv bashio
# ==============================================================================
# Cloudflare Tunnel Service
#
# Supports two modes:
# 1. Quick Tunnel (default): Zero config, auto-generated URL
# 2. Named Tunnel: Custom domain with Cloudflare account
#
# Quick Tunnel is the default - just enable and go!
# ==============================================================================

TUNNEL_CONFIG_DIR=/data/cloudflare
TUNNEL_URL_FILE=/data/cloudflare/tunnel_url.txt
CLOUDFLARE_CONFIG=/data/cloudflare_config.json
BACKOFF_FILE=/tmp/cloudflared_backoff
LOG_FILE=/tmp/cloudflared.log

# Check if tunnel is enabled
if [ ! -f "$TUNNEL_CONFIG_DIR/enabled" ]; then
    bashio::log.info "Cloudflare Tunnel not enabled, service sleeping..."
    exec sleep infinity
fi

# Implement exponential backoff for restart protection
if [ -f "$BACKOFF_FILE" ]; then
    LAST_RUN=$(cat "$BACKOFF_FILE" 2>/dev/null || echo "0")
    NOW=$(date +%s)
    DIFF=$((NOW - LAST_RUN))
    if [ "$DIFF" -lt 30 ]; then
        BACKOFF=30
        bashio::log.warning "Cloudflare tunnel failed recently, waiting ${BACKOFF}s before retry..."
        sleep "$BACKOFF"
    fi
fi
date +%s > "$BACKOFF_FILE"

# Determine tunnel mode
TUNNEL_MODE="quick"  # Default to quick tunnel
TUNNEL_TOKEN=""

# Check for named tunnel token
if [ -f "$TUNNEL_CONFIG_DIR/tunnel_token" ]; then
    TUNNEL_TOKEN=$(cat "$TUNNEL_CONFIG_DIR/tunnel_token" | tr -d '[:space:]')
    if [ -n "$TUNNEL_TOKEN" ] && [ "$TUNNEL_TOKEN" != "" ]; then
        TUNNEL_MODE="named"
    fi
fi

mkdir -p "$TUNNEL_CONFIG_DIR"

# Function to capture URL from cloudflared output
capture_url() {
    local logfile="$1"
    while true; do
        if [ -f "$logfile" ]; then
            URL=$(grep -oE 'https://[a-zA-Z0-9-]+\.trycloudflare\.com' "$logfile" 2>/dev/null | head -1)
            if [ -n "$URL" ]; then
                echo "$URL" > "$TUNNEL_URL_FILE"
                bashio::log.info "=============================================="
                bashio::log.info "REMOTE ACCESS URL: $URL"
                bashio::log.info "=============================================="
                bashio::log.info "Mobile app can now connect from anywhere!"

                # Update config file with the URL
                if [ -f "$CLOUDFLARE_CONFIG" ]; then
                    TMP_FILE=$(mktemp)
                    jq --arg url "$URL" '.tunnel_url = $url' "$CLOUDFLARE_CONFIG" > "$TMP_FILE" 2>/dev/null && mv "$TMP_FILE" "$CLOUDFLARE_CONFIG"
                else
                    echo "{\"enabled\": true, \"tunnel_url\": \"$URL\", \"mode\": \"quick\"}" > "$CLOUDFLARE_CONFIG"
                fi
                # Clear backoff on success
                rm -f "$BACKOFF_FILE"
                break
            fi
        fi
        sleep 2
    done
}

if [ "$TUNNEL_MODE" = "named" ]; then
    # ========================================
    # Named Tunnel Mode (with token/custom domain)
    # ========================================
    bashio::log.info "Starting Cloudflare Named Tunnel..."
    bashio::log.info "Using configured tunnel token for custom domain"

    exec /usr/local/bin/cloudflared tunnel run --token "$TUNNEL_TOKEN"
else
    # ========================================
    # Quick Tunnel Mode (zero config)
    # ========================================
    bashio::log.info "Starting Cloudflare Quick Tunnel..."
    bashio::log.info "Generating temporary public URL (no account required)"

    # Clear previous URL and log
    rm -f "$TUNNEL_URL_FILE" "$LOG_FILE"

    # Start URL capture in background
    capture_url "$LOG_FILE" &
    CAPTURE_PID=$!

    # Run cloudflared with output to log file (using tee to also show in logs)
    # exec replaces this shell with cloudflared, so s6 monitors cloudflared directly
    exec /usr/local/bin/cloudflared tunnel --url http://localhost:7779 --no-autoupdate 2>&1 | tee "$LOG_FILE"
fi

